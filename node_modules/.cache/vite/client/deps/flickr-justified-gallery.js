import "./chunk-G3PMV62Z.js";

// node_modules/flickr-justified-gallery/dist/fjGallery.esm.js
function throttle(delay, callback, options) {
  var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel(options2) {
    var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce(delay, callback, options) {
  var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}
var rafSchd = function rafSchd2(fn) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn.apply(void 0, lastArgs);
    });
  };
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var Row = function(params) {
  this.index = params.index;
  this.top = params.top;
  this.left = params.left;
  this.width = params.width;
  this.spacing = params.spacing;
  this.targetRowHeight = params.targetRowHeight;
  this.targetRowHeightTolerance = params.targetRowHeightTolerance;
  this.minAspectRatio = this.width / params.targetRowHeight * (1 - params.targetRowHeightTolerance);
  this.maxAspectRatio = this.width / params.targetRowHeight * (1 + params.targetRowHeightTolerance);
  this.edgeCaseMinRowHeight = params.edgeCaseMinRowHeight;
  this.edgeCaseMaxRowHeight = params.edgeCaseMaxRowHeight;
  this.widowLayoutStyle = params.widowLayoutStyle;
  this.isBreakoutRow = params.isBreakoutRow;
  this.items = [];
  this.height = 0;
};
Row.prototype = {
  /**
   * Attempt to add a single item to the row.
   * This is the heart of the justified algorithm.
   * This method is direction-agnostic; it deals only with sizes, not positions.
   *
   * If the item fits in the row, without pushing row height beyond min/max tolerance,
   * the item is added and the method returns true.
   *
   * If the item leaves row height too high, there may be room to scale it down and add another item.
   * In this case, the item is added and the method returns true, but the row is incomplete.
   *
   * If the item leaves row height too short, there are too many items to fit within tolerance.
   * The method will either accept or reject the new item, favoring the resulting row height closest to within tolerance.
   * If the item is rejected, left/right padding will be required to fit the row height within tolerance;
   * if the item is accepted, top/bottom cropping will be required to fit the row height within tolerance.
   *
   * @method addItem
   * @param itemData {Object} Item layout data, containing item aspect ratio.
   * @return {Boolean} True if successfully added; false if rejected.
   */
  addItem: function(itemData) {
    const newItems = this.items.concat(itemData);
    const rowWidthWithoutSpacing = this.width - (newItems.length - 1) * this.spacing;
    const newAspectRatio = newItems.reduce(function(sum, item) {
      return sum + item.aspectRatio;
    }, 0);
    const targetAspectRatio = rowWidthWithoutSpacing / this.targetRowHeight;
    let previousRowWidthWithoutSpacing;
    let previousAspectRatio;
    let previousTargetAspectRatio;
    if (this.isBreakoutRow) {
      if (this.items.length === 0) {
        if (itemData.aspectRatio >= 1) {
          this.items.push(itemData);
          this.completeLayout(rowWidthWithoutSpacing / itemData.aspectRatio, "justify");
          return true;
        }
      }
    }
    if (newAspectRatio < this.minAspectRatio) {
      this.items.push(Object.assign({}, itemData));
      return true;
    } else if (newAspectRatio > this.maxAspectRatio) {
      if (this.items.length === 0) {
        this.items.push(Object.assign({}, itemData));
        this.completeLayout(rowWidthWithoutSpacing / newAspectRatio, "justify");
        return true;
      }
      previousRowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing;
      previousAspectRatio = this.items.reduce(function(sum, item) {
        return sum + item.aspectRatio;
      }, 0);
      previousTargetAspectRatio = previousRowWidthWithoutSpacing / this.targetRowHeight;
      if (Math.abs(newAspectRatio - targetAspectRatio) > Math.abs(previousAspectRatio - previousTargetAspectRatio)) {
        this.completeLayout(previousRowWidthWithoutSpacing / previousAspectRatio, "justify");
        return false;
      } else {
        this.items.push(Object.assign({}, itemData));
        this.completeLayout(rowWidthWithoutSpacing / newAspectRatio, "justify");
        return true;
      }
    } else {
      this.items.push(Object.assign({}, itemData));
      this.completeLayout(rowWidthWithoutSpacing / newAspectRatio, "justify");
      return true;
    }
  },
  /**
   * Check if a row has completed its layout.
   *
   * @method isLayoutComplete
   * @return {Boolean} True if complete; false if not.
   */
  isLayoutComplete: function() {
    return this.height > 0;
  },
  /**
   * Set row height and compute item geometry from that height.
   * Will justify items within the row unless instructed not to.
   *
   * @method completeLayout
   * @param newHeight {Number} Set row height to this value.
   * @param widowLayoutStyle {String} How should widows display? Supported: left | justify | center
   */
  completeLayout: function(newHeight, widowLayoutStyle) {
    let itemWidthSum = this.left;
    const rowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing;
    let clampedToNativeRatio;
    let clampedHeight;
    let errorWidthPerItem;
    let roundedCumulativeErrors;
    let singleItemGeometry;
    let centerOffset;
    if (typeof widowLayoutStyle === "undefined" || ["justify", "center", "left"].indexOf(widowLayoutStyle) < 0) {
      widowLayoutStyle = "left";
    }
    clampedHeight = Math.max(this.edgeCaseMinRowHeight, Math.min(newHeight, this.edgeCaseMaxRowHeight));
    if (newHeight !== clampedHeight) {
      this.height = clampedHeight;
      clampedToNativeRatio = rowWidthWithoutSpacing / clampedHeight / (rowWidthWithoutSpacing / newHeight);
    } else {
      this.height = newHeight;
      clampedToNativeRatio = 1;
    }
    this.items.forEach(function(item) {
      item.row = this.index;
      item.top = this.top;
      item.width = item.aspectRatio * this.height * clampedToNativeRatio;
      item.height = this.height;
      item.left = itemWidthSum;
      itemWidthSum += item.width + this.spacing;
    }, this);
    if (widowLayoutStyle === "justify") {
      itemWidthSum -= this.spacing + this.left;
      errorWidthPerItem = (itemWidthSum - this.width) / this.items.length;
      roundedCumulativeErrors = this.items.map(function(item, i) {
        return Math.round((i + 1) * errorWidthPerItem);
      });
      if (this.items.length === 1) {
        singleItemGeometry = this.items[0];
        singleItemGeometry.width -= Math.round(errorWidthPerItem);
      } else {
        this.items.forEach(function(item, i) {
          if (i > 0) {
            item.left -= roundedCumulativeErrors[i - 1];
            item.width -= roundedCumulativeErrors[i] - roundedCumulativeErrors[i - 1];
          } else {
            item.width -= roundedCumulativeErrors[i];
          }
        });
      }
    } else if (widowLayoutStyle === "center") {
      centerOffset = (this.width - itemWidthSum) / 2;
      this.items.forEach(function(item) {
        item.left += centerOffset + this.spacing;
      }, this);
    }
  },
  /**
   * Force completion of row layout with current items.
   *
   * @method forceComplete
   * @param fitToWidth {Boolean} Stretch current items to fill the row width.
   *                             This will likely result in padding.
   * @param fitToWidth {Number}
   */
  forceComplete: function(fitToWidth, rowHeight) {
    if (typeof rowHeight === "number") {
      this.completeLayout(rowHeight, this.widowLayoutStyle);
    } else {
      this.completeLayout(this.targetRowHeight, this.widowLayoutStyle);
    }
  },
  /**
   * Return layout data for items within row.
   * Note: returns actual list, not a copy.
   *
   * @method getItems
   * @return Layout data for items within row.
   */
  getItems: function() {
    return this.items;
  }
};
function createNewRow(layoutConfig, layoutData) {
  let isBreakoutRow;
  if (layoutConfig.fullWidthBreakoutRowCadence !== false) {
    if ((layoutData._rows.length + 1) % layoutConfig.fullWidthBreakoutRowCadence === 0) {
      isBreakoutRow = true;
    }
  }
  return new Row({
    index: layoutData._rows.length,
    top: layoutData._containerHeight,
    left: layoutConfig.containerPadding.left,
    width: layoutConfig.containerWidth - layoutConfig.containerPadding.left - layoutConfig.containerPadding.right,
    spacing: layoutConfig.boxSpacing.horizontal,
    targetRowHeight: layoutConfig.targetRowHeight,
    targetRowHeightTolerance: layoutConfig.targetRowHeightTolerance,
    edgeCaseMinRowHeight: layoutConfig.edgeCaseMinRowHeight * layoutConfig.targetRowHeight,
    edgeCaseMaxRowHeight: layoutConfig.edgeCaseMaxRowHeight * layoutConfig.targetRowHeight,
    rightToLeft: false,
    isBreakoutRow,
    widowLayoutStyle: layoutConfig.widowLayoutStyle
  });
}
function addRow(layoutConfig, layoutData, row) {
  layoutData._rows.push(row);
  layoutData._layoutItems = layoutData._layoutItems.concat(row.getItems());
  layoutData._containerHeight += row.height + layoutConfig.boxSpacing.vertical;
  return row.items;
}
function computeLayout(layoutConfig, layoutData, itemLayoutData) {
  let laidOutItems = [];
  let itemAdded;
  let currentRow;
  let nextToLastRowHeight;
  if (layoutConfig.forceAspectRatio) {
    itemLayoutData.forEach(function(itemData) {
      itemData.forcedAspectRatio = true;
      itemData.aspectRatio = layoutConfig.forceAspectRatio;
    });
  }
  itemLayoutData.some(function(itemData, i) {
    if (isNaN(itemData.aspectRatio)) {
      throw new Error("Item " + i + " has an invalid aspect ratio");
    }
    if (!currentRow) {
      currentRow = createNewRow(layoutConfig, layoutData);
    }
    itemAdded = currentRow.addItem(itemData);
    if (currentRow.isLayoutComplete()) {
      laidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));
      if (layoutData._rows.length >= layoutConfig.maxNumRows) {
        currentRow = null;
        return true;
      }
      currentRow = createNewRow(layoutConfig, layoutData);
      if (!itemAdded) {
        itemAdded = currentRow.addItem(itemData);
        if (currentRow.isLayoutComplete()) {
          laidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));
          if (layoutData._rows.length >= layoutConfig.maxNumRows) {
            currentRow = null;
            return true;
          }
          currentRow = createNewRow(layoutConfig, layoutData);
        }
      }
    }
  });
  if (currentRow && currentRow.getItems().length && layoutConfig.showWidows) {
    if (layoutData._rows.length) {
      if (layoutData._rows[layoutData._rows.length - 1].isBreakoutRow) {
        nextToLastRowHeight = layoutData._rows[layoutData._rows.length - 1].targetRowHeight;
      } else {
        nextToLastRowHeight = layoutData._rows[layoutData._rows.length - 1].height;
      }
      currentRow.forceComplete(false, nextToLastRowHeight);
    } else {
      currentRow.forceComplete(false);
    }
    laidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));
    layoutConfig._widowCount = currentRow.getItems().length;
  }
  layoutData._containerHeight = layoutData._containerHeight - layoutConfig.boxSpacing.vertical;
  layoutData._containerHeight = layoutData._containerHeight + layoutConfig.containerPadding.bottom;
  return {
    containerHeight: layoutData._containerHeight,
    widowCount: layoutConfig._widowCount,
    boxes: layoutData._layoutItems
  };
}
function index(input, config) {
  let layoutConfig = {};
  const layoutData = {};
  const defaults = {
    containerWidth: 1060,
    containerPadding: 10,
    boxSpacing: 10,
    targetRowHeight: 320,
    targetRowHeightTolerance: 0.25,
    edgeCaseMinRowHeight: 0.5,
    edgeCaseMaxRowHeight: 2.5,
    maxNumRows: Number.POSITIVE_INFINITY,
    forceAspectRatio: false,
    showWidows: true,
    fullWidthBreakoutRowCadence: false,
    widowLayoutStyle: "left"
  };
  const containerPadding = {};
  const boxSpacing = {};
  config = config || {};
  layoutConfig = Object.assign(defaults, config);
  containerPadding.top = !isNaN(parseFloat(layoutConfig.containerPadding.top)) ? layoutConfig.containerPadding.top : layoutConfig.containerPadding;
  containerPadding.right = !isNaN(parseFloat(layoutConfig.containerPadding.right)) ? layoutConfig.containerPadding.right : layoutConfig.containerPadding;
  containerPadding.bottom = !isNaN(parseFloat(layoutConfig.containerPadding.bottom)) ? layoutConfig.containerPadding.bottom : layoutConfig.containerPadding;
  containerPadding.left = !isNaN(parseFloat(layoutConfig.containerPadding.left)) ? layoutConfig.containerPadding.left : layoutConfig.containerPadding;
  boxSpacing.horizontal = !isNaN(parseFloat(layoutConfig.boxSpacing.horizontal)) ? layoutConfig.boxSpacing.horizontal : layoutConfig.boxSpacing;
  boxSpacing.vertical = !isNaN(parseFloat(layoutConfig.boxSpacing.vertical)) ? layoutConfig.boxSpacing.vertical : layoutConfig.boxSpacing;
  layoutConfig.containerPadding = containerPadding;
  layoutConfig.boxSpacing = boxSpacing;
  layoutData._layoutItems = [];
  layoutData._awakeItems = [];
  layoutData._inViewportItems = [];
  layoutData._leadingOrphans = [];
  layoutData._trailingOrphans = [];
  layoutData._containerHeight = layoutConfig.containerPadding.top;
  layoutData._rows = [];
  layoutData._orphans = [];
  layoutConfig._widowCount = 0;
  return computeLayout(layoutConfig, layoutData, input.map(function(item) {
    if (item.width && item.height) {
      return {
        aspectRatio: item.width / item.height
      };
    } else {
      return {
        aspectRatio: item
      };
    }
  }));
}
var betterJustifiedLayout = index;
var justifiedLayout = getDefaultExportFromCjs(betterJustifiedLayout);
function ready(callback) {
  if (document.readyState === "complete" || document.readyState === "interactive") {
    callback();
  } else {
    document.addEventListener("DOMContentLoaded", callback, {
      capture: true,
      once: true,
      passive: true
    });
  }
}
var win;
if (typeof window !== "undefined") {
  win = window;
} else if (typeof global !== "undefined") {
  win = global;
} else if (typeof self !== "undefined") {
  win = self;
} else {
  win = {};
}
var global$1 = win;
function getImgDimensions(img, cb) {
  let interval;
  let hasSize = false;
  let addedListeners = false;
  const onHasSize = () => {
    if (hasSize) {
      cb(hasSize);
      return;
    }
    if (!img.naturalWidth) {
      return;
    }
    hasSize = {
      width: img.naturalWidth,
      height: img.naturalHeight
    };
    cb(hasSize);
    clearInterval(interval);
    if (addedListeners) {
      removeListeners();
    }
  };
  const onLoaded = () => {
    onHasSize();
  };
  const onError = () => {
    onHasSize();
  };
  const checkSize = () => {
    if (img.naturalWidth > 0) {
      onHasSize();
    }
  };
  const addListeners = () => {
    addedListeners = true;
    img.addEventListener("load", onLoaded);
    img.addEventListener("error", onError);
  };
  const removeListeners = () => {
    addedListeners = false;
    img.removeEventListener("load", onLoaded);
    img.removeEventListener("error", onError);
  };
  checkSize();
  if (!hasSize) {
    addListeners();
    interval = setInterval(checkSize, 100);
  }
}
var fjGalleryList = [];
var updateFjGallery = rafSchd(() => {
  fjGalleryList.forEach((item) => {
    item.resize();
  });
});
global$1.addEventListener("resize", updateFjGallery);
global$1.addEventListener("orientationchange", updateFjGallery);
global$1.addEventListener("load", updateFjGallery);
ready(() => {
  updateFjGallery();
});
var instanceID = 0;
var FJGallery = class {
  constructor(container, userOptions) {
    const self2 = this;
    self2.instanceID = instanceID;
    instanceID += 1;
    self2.$container = container;
    self2.images = [];
    self2.defaults = {
      itemSelector: ".fj-gallery-item",
      imageSelector: "img",
      gutter: 10,
      // supports object like `{ horizontal: 10, vertical: 10 }`.
      rowHeight: 320,
      rowHeightTolerance: 0.25,
      // [0, 1]
      maxRowsCount: Number.POSITIVE_INFINITY,
      edgeCaseMinRowHeight: 0.5,
      edgeCaseMaxRowHeight: 2.5,
      lastRow: "left",
      // left, center, right, hide
      transitionDuration: "0.3s",
      calculateItemsHeight: false,
      resizeDebounce: 100,
      isRtl: self2.css(self2.$container, "direction") === "rtl",
      // events
      onInit: null,
      // function() {}
      onDestroy: null,
      // function() {}
      onAppendImages: null,
      // function() {}
      onBeforeJustify: null,
      // function() {}
      onJustify: null
      // function() {}
    };
    const dataOptions = self2.$container.dataset || {};
    const pureDataOptions = {};
    Object.keys(dataOptions).forEach((key) => {
      const loweCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);
      if (loweCaseOption && typeof self2.defaults[loweCaseOption] !== "undefined") {
        pureDataOptions[loweCaseOption] = dataOptions[key];
      }
    });
    self2.options = {
      ...self2.defaults,
      ...pureDataOptions,
      ...userOptions
    };
    self2.pureOptions = {
      ...self2.options
    };
    self2.resize = debounce(self2.options.resizeDebounce, self2.resize);
    self2.justify = rafSchd(self2.justify.bind(self2));
    self2.init();
  }
  // add styles to element
  // eslint-disable-next-line class-methods-use-this
  css(el, styles) {
    if (typeof styles === "string") {
      return global$1.getComputedStyle(el).getPropertyValue(styles);
    }
    Object.keys(styles).forEach((key) => {
      el.style[key] = styles[key];
    });
    return el;
  }
  // set temporary transition with event listener
  applyTransition($item, properties) {
    const self2 = this;
    self2.onTransitionEnd($item)();
    self2.css($item, {
      "transition-property": properties.join(", "),
      "transition-duration": self2.options.transitionDuration
    });
    $item.addEventListener("transitionend", self2.onTransitionEnd($item, properties), false);
  }
  onTransitionEnd($item) {
    const self2 = this;
    return () => {
      self2.css($item, {
        "transition-property": "",
        "transition-duration": ""
      });
      $item.removeEventListener("transitionend", self2.onTransitionEnd($item));
    };
  }
  // add to fjGallery instances list
  addToFjGalleryList() {
    fjGalleryList.push(this);
    updateFjGallery();
  }
  // remove from fjGallery instances list
  removeFromFjGalleryList() {
    const self2 = this;
    fjGalleryList.forEach((item, key) => {
      if (item.instanceID === self2.instanceID) {
        fjGalleryList.splice(key, 1);
      }
    });
  }
  init() {
    const self2 = this;
    self2.appendImages(self2.$container.querySelectorAll(self2.options.itemSelector));
    self2.addToFjGalleryList();
    if (self2.options.onInit) {
      self2.options.onInit.call(self2);
    }
  }
  // append images
  appendImages($images) {
    const self2 = this;
    if (global$1.jQuery && $images instanceof global$1.jQuery) {
      $images = $images.get();
    }
    if (!$images || !$images.length) {
      return;
    }
    $images.forEach(($item) => {
      if ($item && !$item.fjGalleryImage && $item.querySelector) {
        const $image = $item.querySelector(self2.options.imageSelector);
        if ($image) {
          $item.fjGalleryImage = self2;
          const data = {
            $item,
            $image,
            width: parseFloat($image.getAttribute("width")) || false,
            height: parseFloat($image.getAttribute("height")) || false,
            loadSizes() {
              const itemData = this;
              getImgDimensions($image, (dimensions) => {
                if (itemData.width !== dimensions.width || itemData.height !== dimensions.height) {
                  itemData.width = dimensions.width;
                  itemData.height = dimensions.height;
                  self2.resize();
                }
              });
            }
          };
          data.loadSizes();
          self2.images.push(data);
        }
      }
    });
    if (self2.options.onAppendImages) {
      self2.options.onAppendImages.call(self2, [$images]);
    }
    self2.justify();
  }
  // justify images
  justify() {
    const self2 = this;
    const justifyArray = [];
    self2.justifyCount = (self2.justifyCount || 0) + 1;
    if (self2.options.onBeforeJustify) {
      self2.options.onBeforeJustify.call(self2);
    }
    self2.images.forEach((data) => {
      if (data.width && data.height) {
        justifyArray.push(data.width / data.height);
      }
    });
    const justifiedOptions = {
      containerWidth: self2.$container.getBoundingClientRect().width,
      containerPadding: {
        top: parseFloat(self2.css(self2.$container, "padding-top")) || 0,
        right: parseFloat(self2.css(self2.$container, "padding-right")) || 0,
        bottom: parseFloat(self2.css(self2.$container, "padding-bottom")) || 0,
        left: parseFloat(self2.css(self2.$container, "padding-left")) || 0
      },
      boxSpacing: self2.options.gutter,
      targetRowHeight: self2.options.rowHeight,
      targetRowHeightTolerance: self2.options.rowHeightTolerance,
      maxNumRows: self2.options.maxRowsCount,
      edgeCaseMinRowHeight: self2.options.edgeCaseMinRowHeight,
      edgeCaseMaxRowHeight: self2.options.edgeCaseMaxRowHeight,
      showWidows: self2.options.lastRow !== "hide"
    };
    const justifiedData = justifiedLayout(justifyArray, justifiedOptions);
    if (justifiedData.widowCount && (self2.options.lastRow === "center" || self2.options.lastRow === "right")) {
      const lastItemData = justifiedData.boxes[justifiedData.boxes.length - 1];
      let gapSize = justifiedOptions.containerWidth - lastItemData.width - lastItemData.left;
      if (self2.options.lastRow === "center") {
        gapSize /= 2;
      }
      if (self2.options.lastRow === "right") {
        gapSize -= justifiedOptions.containerPadding.right;
      }
      for (let i2 = 1; i2 <= justifiedData.widowCount; i2 += 1) {
        justifiedData.boxes[justifiedData.boxes.length - i2].left = justifiedData.boxes[justifiedData.boxes.length - i2].left + gapSize;
      }
    }
    if (self2.options.isRtl) {
      justifiedData.boxes.forEach((boxData, i2) => {
        justifiedData.boxes[i2].left = justifiedOptions.containerWidth - justifiedData.boxes[i2].left - justifiedData.boxes[i2].width - justifiedOptions.containerPadding.right + justifiedOptions.containerPadding.left;
      });
    }
    let i = 0;
    let additionalTopOffset = 0;
    const rowsMaxHeight = {};
    self2.images.forEach((data, imgI) => {
      if (justifiedData.boxes[i] && data.width && data.height) {
        if (self2.options.calculateItemsHeight && typeof rowsMaxHeight[justifiedData.boxes[i].row] === "undefined" && Object.keys(rowsMaxHeight).length) {
          additionalTopOffset += rowsMaxHeight[Object.keys(rowsMaxHeight).pop()] - justifiedData.boxes[imgI - 1].height;
        }
        if (self2.options.transitionDuration && self2.justifyCount > 1) {
          self2.applyTransition(data.$item, ["transform"]);
        }
        self2.css(data.$item, {
          display: "",
          position: "absolute",
          transform: `translateX(${justifiedData.boxes[i].left}px) translateY(${justifiedData.boxes[i].top + additionalTopOffset}px) translateZ(0)`,
          width: `${justifiedData.boxes[i].width}px`
        });
        if (self2.options.calculateItemsHeight) {
          const rect = data.$item.getBoundingClientRect();
          if (typeof rowsMaxHeight[justifiedData.boxes[i].row] === "undefined" || rowsMaxHeight[justifiedData.boxes[i].row] < rect.height) {
            rowsMaxHeight[justifiedData.boxes[i].row] = rect.height;
          }
        }
        i += 1;
      } else {
        self2.css(data.$item, {
          display: "none"
        });
      }
    });
    if (self2.options.calculateItemsHeight && Object.keys(rowsMaxHeight).length) {
      additionalTopOffset += rowsMaxHeight[Object.keys(rowsMaxHeight).pop()] - justifiedData.boxes[justifiedData.boxes.length - 1].height;
    }
    if (self2.options.transitionDuration) {
      self2.applyTransition(self2.$container, ["height"]);
    }
    self2.css(self2.$container, {
      height: `${justifiedData.containerHeight + additionalTopOffset}px`
    });
    if (self2.options.onJustify) {
      self2.options.onJustify.call(self2);
    }
  }
  // update options and resize gallery items
  updateOptions(options) {
    const self2 = this;
    self2.options = {
      ...self2.options,
      ...options
    };
    self2.justify();
  }
  destroy() {
    const self2 = this;
    self2.removeFromFjGalleryList();
    self2.justifyCount = 0;
    if (self2.options.onDestroy) {
      self2.options.onDestroy.call(self2);
    }
    self2.css(self2.$container, {
      height: "",
      transition: ""
    });
    self2.images.forEach((data) => {
      self2.css(data.$item, {
        position: "",
        transform: "",
        transition: "",
        width: "",
        height: ""
      });
    });
    self2.images.forEach((val) => {
      delete val.$item.fjGalleryImage;
    });
    delete self2.$container.fjGallery;
  }
  resize() {
    const self2 = this;
    self2.justify();
  }
};
var fjGallery = function(items, options, ...args) {
  if (typeof HTMLElement === "object" ? items instanceof HTMLElement : items && typeof items === "object" && items !== null && items.nodeType === 1 && typeof items.nodeName === "string") {
    items = [items];
  }
  const len = items.length;
  let k = 0;
  let ret;
  for (k; k < len; k += 1) {
    if (typeof options === "object" || typeof options === "undefined") {
      if (!items[k].fjGallery) {
        items[k].fjGallery = new FJGallery(items[k], options);
      }
    } else if (items[k].fjGallery) {
      ret = items[k].fjGallery[options].apply(items[k].fjGallery, args);
    }
    if (typeof ret !== "undefined") {
      return ret;
    }
  }
  return items;
};
fjGallery.constructor = FJGallery;
export {
  fjGallery as default
};
/*! Bundled license information:

flickr-justified-gallery/dist/fjGallery.esm.js:
  (*!
   * Flickr's Justified Gallery [fjGallery] v2.2.0 (https://flickr-justified-gallery.nkdev.info)
   * Copyright 2024 nK <https://nkdev.info>
   * Licensed under MIT (https://github.com/nk-o/flickr-justified-gallery/blob/master/LICENSE)
   *)
  (*!
   * Copyright 2019 SmugMug, Inc. | Copyright 2024 nK
   * Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.
   * @license
   *)
*/
//# sourceMappingURL=flickr-justified-gallery.js.map
